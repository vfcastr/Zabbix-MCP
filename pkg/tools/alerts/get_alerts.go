// Copyright vfcastr 2025
// SPDX-License-Identifier: MPL-2.0

package alerts

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	log "github.com/sirupsen/logrus"
	"github.com/vfcastr/Zabbix-MCP/pkg/client"
	"github.com/vfcastr/Zabbix-MCP/pkg/utils"
)

type Alert struct {
	AlertID     string `json:"alertid"`
	ActionID    string `json:"actionid"`
	AlertType   string `json:"alerttype"`
	Clock       string `json:"clock"`
	Error       string `json:"error"`
	EscStep     string `json:"esc_step"`
	EventID     string `json:"eventid"`
	MediaTypeID string `json:"mediatypeid"`
	Message     string `json:"message"`
	Retries     string `json:"retries"`
	SendTo      string `json:"sendto"`
	Status      string `json:"status"`
	Subject     string `json:"subject"`
	UserID      string `json:"userid"`
}

type AlertGetParams struct {
	Output       interface{} `json:"output,omitempty"`
	AlertIDs     []string    `json:"alertids,omitempty"`
	ActionIDs    []string    `json:"actionids,omitempty"`
	EventIDs     []string    `json:"eventids,omitempty"`
	GroupIDs     []string    `json:"groupids,omitempty"`
	HostIDs      []string    `json:"hostids,omitempty"`
	MediaTypeIDs []string    `json:"mediatypeids,omitempty"`
	UserIDs      []string    `json:"userids,omitempty"`
	TimeFrom     int64       `json:"time_from,omitempty"`
	TimeTill     int64       `json:"time_till,omitempty"`
	SelectHosts  interface{} `json:"selectHosts,omitempty"`
	SelectUsers  interface{} `json:"selectUsers,omitempty"`
	SortField    []string    `json:"sortfield,omitempty"`
	SortOrder    []string    `json:"sortorder,omitempty"`
	Limit        int         `json:"limit,omitempty"`
}

func GetAlerts(logger *log.Logger) server.ServerTool {
	return server.ServerTool{
		Tool: mcp.NewTool("get_alerts",
			mcp.WithToolAnnotation(mcp.ToolAnnotation{IdempotentHint: utils.ToBoolPtr(true)}),
			mcp.WithDescription("Retrieve alerts that have been generated by actions."),
			mcp.WithString("alertids", mcp.Description("Comma-separated list of alert IDs to filter by")),
			mcp.WithString("actionids", mcp.Description("Comma-separated list of action IDs to filter by")),
			mcp.WithString("eventids", mcp.Description("Comma-separated list of event IDs to filter by")),
			mcp.WithString("groupids", mcp.Description("Comma-separated list of host group IDs to filter by")),
			mcp.WithString("hostids", mcp.Description("Comma-separated list of host IDs to filter by")),
			mcp.WithString("mediatypeids", mcp.Description("Comma-separated list of media type IDs to filter by")),
			mcp.WithString("userids", mcp.Description("Comma-separated list of user IDs to filter by")),
			mcp.WithNumber("time_from", mcp.Description("Return only alerts after this Unix timestamp")),
			mcp.WithNumber("time_till", mcp.Description("Return only alerts before this Unix timestamp")),
			mcp.WithNumber("limit", mcp.Description("Max alerts to return (default: 100)")),
		),
		Handler: func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return getAlertsHandler(ctx, req, logger)
		},
	}
}

func getAlertsHandler(ctx context.Context, req mcp.CallToolRequest, logger *log.Logger) (*mcp.CallToolResult, error) {
	zabbix, err := client.GetZabbixClientFromContext(ctx, logger)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to get Zabbix client: %v", err)), nil
	}

	params := AlertGetParams{
		Output:    "extend",
		SortField: []string{"clock", "alertid"},
		SortOrder: []string{"DESC", "DESC"},
		Limit:     100,
	}

	if args, ok := req.Params.Arguments.(map[string]interface{}); ok && args != nil {
		if v, ok := args["alertids"].(string); ok && v != "" {
			params.AlertIDs = splitAndTrim(v)
		}
		if v, ok := args["actionids"].(string); ok && v != "" {
			params.ActionIDs = splitAndTrim(v)
		}
		if v, ok := args["eventids"].(string); ok && v != "" {
			params.EventIDs = splitAndTrim(v)
		}
		if v, ok := args["groupids"].(string); ok && v != "" {
			params.GroupIDs = splitAndTrim(v)
		}
		if v, ok := args["hostids"].(string); ok && v != "" {
			params.HostIDs = splitAndTrim(v)
		}
		if v, ok := args["mediatypeids"].(string); ok && v != "" {
			params.MediaTypeIDs = splitAndTrim(v)
		}
		if v, ok := args["userids"].(string); ok && v != "" {
			params.UserIDs = splitAndTrim(v)
		}
		if v, ok := args["time_from"].(float64); ok && v > 0 {
			params.TimeFrom = int64(v)
		}
		if v, ok := args["time_till"].(float64); ok && v > 0 {
			params.TimeTill = int64(v)
		}
		if v, ok := args["limit"].(float64); ok && v > 0 {
			params.Limit = int(v)
		}
	}

	result, err := zabbix.Call("alert.get", params)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to get alerts: %v", err)), nil
	}

	var alerts []Alert
	json.Unmarshal(result, &alerts)
	jsonData, _ := json.MarshalIndent(alerts, "", "  ")
	return mcp.NewToolResultText(string(jsonData)), nil
}

func splitAndTrim(s string) []string {
	var result []string
	for _, part := range strings.Split(s, ",") {
		if trimmed := strings.TrimSpace(part); trimmed != "" {
			result = append(result, trimmed)
		}
	}
	return result
}
